#!/usr/bin/env node
/**
 * Enhanced download script:
 * 1. (Placeholder) Download / refresh SDK versions into lib/<version>/index.js
 * 2. Auto update package.json exports / typesVersions / main / files
 * 3. Generate root index.js pointing to latest version
 *
 * Existing download logic should be placed where indicated.
 */
const fs = require('fs');
const path = require('path');
const https = require('https');

const ROOT = path.resolve(__dirname, '..');
const LIB_DIR = path.join(ROOT, 'lib');
const PKG_FILE = path.join(ROOT, 'package.json');
const ROOT_INDEX = path.join(ROOT, 'index.js');

function log(...args) {
  console.log('[download-sdk]', ...args);
}

// Simple semver comparator (x.y.z)
function compareSemver(a, b) {
  const pa = a.split('.').map(Number);
  const pb = b.split('.').map(Number);
  for (let i = 0; i < 3; i++) {
    const diff = (pb[i] || 0) - (pa[i] || 0);
    if (diff !== 0) return diff; // desc
  }
  return 0;
}

function getVersionDirs() {
  if (!fs.existsSync(LIB_DIR)) return [];
  return fs.readdirSync(LIB_DIR)
    .filter(d => /^\d+\.\d+\.\d+$/.test(d))
    .filter(d => fs.existsSync(path.join(LIB_DIR, d, 'index.js')))
    .sort(compareSemver); // newest first
}

// Generate root index.js
function writeRootIndex(latestVersion) {
  const content =
`// Auto-generated by scripts/download-sdk.js. Do NOT edit manually.
// Ensure window exists (for Node-based bundler pre-bundling environments)
const g = (typeof globalThis !== 'undefined' ? globalThis : (typeof global !== 'undefined' ? global : this));
if (typeof g.window === 'undefined') g.window = g;

// Require underlying UMD script (it assigns window.wx / window.jWeixin)
require('./lib/${latestVersion}/index.js');

// Retrieve the global export placed by the SDK
const wx = g.wx || g.jWeixin;

// Fallback: if still missing, export an empty object to avoid crashes
const exported = wx || {};

module.exports = exported;
Object.defineProperty(module.exports, '__esModule', { value: true });
Object.defineProperty(module.exports, 'default', { enumerable: false, value: exported });
`;
  fs.writeFileSync(ROOT_INDEX, content);
  log('Updated root index.js ->', latestVersion);
}

// Update package.json metadata
function updatePackageJson(versions, latest) {
  const pkg = JSON.parse(fs.readFileSync(PKG_FILE, 'utf8'));
  pkg.main = 'index.js';
  pkg.types = './index.d.ts';
  if (!pkg.type) pkg.type = 'commonjs';

  // Rebuild exports
  const exportsField = {
    '.': {
      types: './index.d.ts',
      require: './index.js',
      default: './index.js'
    },
    './package.json': './package.json'
  };
  versions.forEach(v => {
    exportsField[`./${v}`] = {
      types: './index.d.ts',
      require: `./lib/${v}/wrapper.js`,
      default: `./lib/${v}/wrapper.js`
    };
  });
  pkg.exports = exportsField;

  // typesVersions
  pkg.typesVersions = {
    '*': versions.reduce((acc, v) => {
      acc[v] = ['index.d.ts'];
      return acc;
    }, { '*': ['index.d.ts'] })
  };

  // files
  pkg.files = Array.from(new Set([...(pkg.files || []), 'lib', 'index.d.ts', 'index.js']));

  fs.writeFileSync(PKG_FILE, JSON.stringify(pkg, null, 2));
  log('package.json exports/typesVersions updated. Latest =', latest);
}

// Download file helper
async function downloadFile(url, filePath) {
  return new Promise((resolve, reject) => {
    const file = fs.createWriteStream(filePath);

    https.get(url, (response) => {
      if (response.statusCode !== 200) {
        file.close();
        fs.unlink(filePath, () => { });
        reject(new Error(`Failed to download: ${response.statusCode}`));
        return;
      }

      response.pipe(file);

      file.on('finish', () => {
        file.close();
        resolve();
      });

      file.on('error', (err) => {
        file.close();
        fs.unlink(filePath, () => { });
        reject(err);
      });

    }).on('error', (err) => {
      file.close();
      fs.unlink(filePath, () => { });
      reject(err);
    });
  });
}

// Placeholder for actual downloading logic
async function downloadIfNeeded() {
  const versionrcPath = path.join(__dirname, '..', '.versionrc');
  const libDir = path.join(__dirname, '..', 'lib');

  if (!fs.existsSync(versionrcPath)) {
    console.error('.versionrc file not found');
    process.exit(1);
  }

  // 清空 lib 目录
  if (fs.existsSync(libDir)) {
    try {
      fs.rmSync(libDir, { recursive: true, force: true });
      log('Cleared lib directory before downloading.');
    } catch (e) {
      // 兼容极少数环境不支持 rmSync
      const entries = fs.readdirSync(libDir);
      for (const entry of entries) {
        fs.rmSync(path.join(libDir, entry), { recursive: true, force: true });
      }
      log('Emptied lib directory (fallback).');
    }
  }
  fs.mkdirSync(libDir, { recursive: true });

  const versions = fs.readFileSync(versionrcPath, 'utf8')
    .split('\n')
    .map(line => line.trim())
    .filter(line => line.length > 0);

  for (const version of versions) {
    console.log(`Processing version: ${version}`);

    const versionDir = path.join(libDir, version);
    if (!fs.existsSync(versionDir)) {
      fs.mkdirSync(versionDir, { recursive: true });
    }

    const url = `https://res.wx.qq.com/open/js/jweixin-${version}.js`;
    const filePath = path.join(versionDir, 'index.js');

    try {
      console.log(`Downloading from: ${url}`);
      await downloadFile(url, filePath);
      console.log(`Successfully downloaded version ${version}`);
    } catch (error) {
      console.error(`Failed to download version ${version}:`, error.message);
    }
  }
}

function patchUMD(file) {
  if (!fs.existsSync(file)) return;
  let code = fs.readFileSync(file, 'utf8');
  // 仅当还未替换过并存在原始模式时执行
  if (code.includes(')(this,function') && !code.includes(')(window,function')) {
    // 备份原始文件
    const originFile = path.join(path.dirname(file), 'index.origin.js');
    if (!fs.existsSync(originFile)) {
        fs.writeFileSync(originFile, code);
        log('Backup original UMD file ->', path.relative(ROOT, originFile));
    }
    code = code.replace(')(this,function', ')(window,function');
    fs.writeFileSync(file, code);
    log('Patched UMD this -> window for', path.relative(ROOT, file));
  }
}

async function main() {
  const args = process.argv.slice(2);
  const onlyMeta = args.includes('--update-meta');

  if (!onlyMeta) {
    await downloadIfNeeded();
  }

  const versions = getVersionDirs();
  if (!versions.length) {
    log('No versions found under lib/, nothing to update.');
    return;
  }

  // 对所有版本打补丁，保证无论默认还是子路径都可安全运行
  versions.forEach(v => {
    const versionDir = path.join(LIB_DIR, v);
    const mainFile = path.join(versionDir, 'index.js');
    patchUMD(mainFile);
    const wrapperFile = path.join(versionDir, 'wrapper.js');
    if (!fs.existsSync(wrapperFile)) {
      const wrapperCode = `// Wrapper to expose jweixin ${v} as proper CommonJS/ESM default export\n`+
`const g = (typeof globalThis !== 'undefined' ? globalThis : (typeof global !== 'undefined' ? global : this));\n`+
`if (typeof g.window === 'undefined') g.window = g;\n`+
`require('./index.js');\n`+
`const wx = g.wx || g.jWeixin || {};\n`+
`module.exports = wx;\n`+
`Object.defineProperty(module.exports, '__esModule', { value: true });\n`+
`Object.defineProperty(module.exports, 'default', { enumerable: false, value: wx });\n`;
      fs.writeFileSync(wrapperFile, wrapperCode);
      log('Created wrapper', path.relative(ROOT, wrapperFile));
    }
  });

  const latest = versions[0];
  writeRootIndex(latest);
  updatePackageJson(versions, latest);
  log('Done.');
}

main().catch(e => {
  console.error(e);
  process.exit(1);
});
