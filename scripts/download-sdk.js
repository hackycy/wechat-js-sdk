#!/usr/bin/env node
/**
 * Enhanced download script:
 * 1. (Placeholder) Download / refresh SDK versions into lib/<version>/index.js
 * 2. Auto update package.json exports / typesVersions / main / files
 * 3. Generate root index.js pointing to latest version
 *
 * Existing download logic should be placed where indicated.
 */
const fs = require('fs');
const path = require('path');
const https = require('https');

const ROOT = path.resolve(__dirname, '..');
const LIB_DIR = path.join(ROOT, 'lib');
const PKG_FILE = path.join(ROOT, 'package.json');
const ROOT_INDEX = path.join(ROOT, 'index.js');

function log(...args) {
  console.log('[download-sdk]', ...args);
}

// Simple semver comparator (x.y.z)
function compareSemver(a, b) {
  const pa = a.split('.').map(Number);
  const pb = b.split('.').map(Number);
  for (let i = 0; i < 3; i++) {
    const diff = (pb[i] || 0) - (pa[i] || 0);
    if (diff !== 0) return diff; // desc
  }
  return 0;
}

function getVersionDirs() {
  if (!fs.existsSync(LIB_DIR)) return [];
  return fs.readdirSync(LIB_DIR)
    .filter(d => /^\d+\.\d+\.\d+$/.test(d))
    .filter(d => fs.existsSync(path.join(LIB_DIR, d, 'index.js')))
    .sort(compareSemver); // newest first
}

// Generate root index.js
function writeRootIndex(latestVersion) {
  const content =
`// Auto-generated by scripts/download-sdk.js. Do NOT edit manually.
const wx = require('./lib/${latestVersion}/index.js');
module.exports = wx;
module.exports.default = wx;
`;
  fs.writeFileSync(ROOT_INDEX, content);
  log('Updated root index.js ->', latestVersion);
}

// Update package.json metadata
function updatePackageJson(versions, latest) {
  const pkg = JSON.parse(fs.readFileSync(PKG_FILE, 'utf8'));
  pkg.main = 'index.js';
  pkg.types = './index.d.ts';
  if (!pkg.type) pkg.type = 'commonjs';

  // Rebuild exports
  const exportsField = {
    '.': {
      types: './index.d.ts',
      require: './index.js',
      default: './index.js'
    },
    './package.json': './package.json'
  };
  versions.forEach(v => {
    exportsField[`./${v}`] = {
      types: './index.d.ts',
      require: `./lib/${v}/index.js`,
      default: `./lib/${v}/index.js`
    };
  });
  pkg.exports = exportsField;

  // typesVersions
  pkg.typesVersions = {
    '*': versions.reduce((acc, v) => {
      acc[v] = ['index.d.ts'];
      return acc;
    }, { '*': ['index.d.ts'] })
  };

  // files
  pkg.files = Array.from(new Set([...(pkg.files || []), 'lib', 'index.d.ts', 'index.js']));

  fs.writeFileSync(PKG_FILE, JSON.stringify(pkg, null, 2));
  log('package.json exports/typesVersions updated. Latest =', latest);
}

// Download file helper
async function downloadFile(url, filePath) {
  return new Promise((resolve, reject) => {
    const file = fs.createWriteStream(filePath);

    https.get(url, (response) => {
      if (response.statusCode !== 200) {
        file.close();
        fs.unlink(filePath, () => { });
        reject(new Error(`Failed to download: ${response.statusCode}`));
        return;
      }

      response.pipe(file);

      file.on('finish', () => {
        file.close();
        resolve();
      });

      file.on('error', (err) => {
        file.close();
        fs.unlink(filePath, () => { });
        reject(err);
      });

    }).on('error', (err) => {
      file.close();
      fs.unlink(filePath, () => { });
      reject(err);
    });
  });
}

// Placeholder for actual downloading logic
async function downloadIfNeeded() {
  const versionrcPath = path.join(__dirname, '..', '.versionrc');
  const libDir = path.join(__dirname, '..', 'lib');

  if (!fs.existsSync(versionrcPath)) {
    console.error('.versionrc file not found');
    process.exit(1);
  }

  const versions = fs.readFileSync(versionrcPath, 'utf8')
    .split('\n')
    .map(line => line.trim())
    .filter(line => line.length > 0);

  if (!fs.existsSync(libDir)) {
    fs.mkdirSync(libDir, { recursive: true });
  }

  for (const version of versions) {
    console.log(`Processing version: ${version}`);

    const versionDir = path.join(libDir, version);
    if (!fs.existsSync(versionDir)) {
      fs.mkdirSync(versionDir, { recursive: true });
    }

    const url = `https://res.wx.qq.com/open/js/jweixin-${version}.js`;
    const filePath = path.join(versionDir, 'index.js');

    try {
      console.log(`Downloading from: ${url}`);
      await downloadFile(url, filePath);
      console.log(`Successfully downloaded version ${version}`);
    } catch (error) {
      console.error(`Failed to download version ${version}:`, error.message);
    }
  }
}

async function main() {
  const args = process.argv.slice(2);
  const onlyMeta = args.includes('--update-meta');

  if (!onlyMeta) {
    await downloadIfNeeded();
  }

  const versions = getVersionDirs();
  if (!versions.length) {
    log('No versions found under lib/, nothing to update.');
    return;
  }
  const latest = versions[0];

  writeRootIndex(latest);
  updatePackageJson(versions, latest);
  log('Done.');
}

main().catch(e => {
  console.error(e);
  process.exit(1);
});
